package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"uilliam.com/sip/lib"
	"uilliam.com/sip/types"
)

// main is the entrypoint of the code-generator
func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <path_to_json>")
		os.Exit(1)
	}

	jsonPath := os.Args[1]
	config, err := loadEndpointConfig(jsonPath)
	if err != nil {
		log.Fatalf("Error loading config: %v", err)
	}

	generatedCode := generateCode(config)

	err = ioutil.WriteFile("generated.go", []byte(generatedCode), 0644)
	if err != nil {
		log.Fatalf("Error writing generated code file: %v", err)
	}

	fmt.Println("Code generation complete! See generated.go")
}

// Load the JSON file into an EndpointConfig struct
func loadEndpointConfig(path string) (*types.EndpointConfig, error) {
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var cfg types.EndpointConfig
	err = json.Unmarshal(content, &cfg)
	if err != nil {
		return nil, err
	}

	return &cfg, nil
}

// generateCode orchestrates all generation steps
func generateCode(cfg *types.EndpointConfig) string {
	var sb strings.Builder

	// 1. Begin with package & imports
	sb.WriteString(`package main

import (
	"fmt"
	"net/http"
	"time"
	"log"
)

// This file is auto-generated by main.go.
// Do not edit this file manually.

`)

	// 2. Include plugin scripts (just to show them)
	sb.WriteString("// Plugin scripts (theoretically):\n")
	for _, plugin := range cfg.Plugins {
		sb.WriteString(fmt.Sprintf("// - %s at %s (trigger: %s)\n",
			plugin.Name, plugin.Script, plugin.Trigger))
	}

	handlerName := "GeneratedHandler"
	sb.WriteString(fmt.Sprintf("\nfunc %s(w http.ResponseWriter, r *http.Request) {\n", handlerName))

	// (a) Ensure method
	sb.WriteString(fmt.Sprintf(`    // Ensure the request method is "%s"
    if r.Method != "%s" {
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
        return
    }
`, cfg.Method, cfg.Method))

	// (b) Rate-limiting snippet (inline)
	if cfg.RateLimit.Limit > 0 {
		sb.WriteString(fmt.Sprintf(`
    // Rate limiting: limit=%d, window=%ds
    // (Pseudo-implementation, you'd need a real store to track requests)
    // if isRateLimited(r) {
    //     http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
    //     return
    // }
`, cfg.RateLimit.Limit, cfg.RateLimit.TimeWindow))
	}

	// (c) Auth code from lib/auth.go
	authCode := lib.GenerateAuthCode(cfg.Auth)
	sb.WriteString(authCode)

	// (d) Logging code from lib/logging.go
	loggingCode := lib.GenerateLoggingCode(cfg.Logging, cfg.Path)
	sb.WriteString(loggingCode)

	// (e) BeforeRequest plugins
	beforeRequestCode := lib.GeneratePluginsCode(cfg.Plugins, "beforeRequest")
	sb.WriteString(beforeRequestCode)

	// (f) Validate request parameters and headers
	sb.WriteString("\n    // Validate request parameters and headers\n")
	for paramName, paramDef := range cfg.Request.Params {
		if paramDef.Required {
			sb.WriteString(fmt.Sprintf(`    // Check if param "%s" is provided
    if r.URL.Query().Get("%s") == "" {
        http.Error(w, "Missing required param '%s'", http.StatusBadRequest)
        return
    }
`, paramName, paramName, paramName))
		}
	}

	for headerName, headerDef := range cfg.Request.Headers {
		if headerDef.Required {
			sb.WriteString(fmt.Sprintf(`    if r.Header.Get("%s") == "" {
        http.Error(w, "Missing required header '%s'", http.StatusBadRequest)
        return
    }
`, headerName, headerName))
		}

		// (g) Cache check
		if cfg.Cache.Enabled {
			sb.WriteString(fmt.Sprintf(`
    // Cache check: type=%s, ttl=%d
    // (Pseudo-implementation)
    // if cachedResponse := checkCache(r); cachedResponse != nil {
    //     w.WriteHeader(http.StatusOK)
    //     w.Write(cachedResponse)
    //     return
    // }
`, cfg.Cache.Type, cfg.Cache.TTL))
		}

		// (h) Database operation
		if strings.ToUpper(cfg.Database.Operation) == "SELECT" {
			sb.WriteString(fmt.Sprintf(`
    // Perform database SELECT on %s with query:
    // "%s"
    // (Pseudo-implementation of DB call)
    // userData, err := dbSelect(statement, someParams)
    // if err != nil {
    //     http.Error(w, "Internal server error", http.StatusInternalServerError)
    //     return
    // }
`, cfg.Database.Connection, cfg.Database.Query.Statement))
		}

		// (i) passThrough plugins
		passThroughCode := lib.GeneratePluginsCode(cfg.Plugins, "passThrough")
		sb.WriteString(passThroughCode)

		// (j) Build response
		sb.WriteString(`
    // Build response
    response := make(map[string]interface{})
`)
		for field, fieldType := range cfg.Response.Fields {
			// We'll use a helper here as well, but let's just inline for brevity:
			exampleValue := exampleValueForType(fieldType)
			sb.WriteString(fmt.Sprintf(`    response["%s"] = %s
`, field, exampleValue))
		}

		sb.WriteString(`
    // Convert response to JSON
    // In a real scenario, you'd import "encoding/json" and do something like:
    // json.NewEncoder(w).Encode(response)
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    fmt.Fprintf(w, "%v", response)
`)

		// (k) Logging end
		loggingEnd := lib.GenerateLoggingEnd(cfg.Logging, cfg.Path)
		sb.WriteString(loggingEnd)

		sb.WriteString("}\n\n")

		// Minimal main function
		sb.WriteString(fmt.Sprintf(`
// StartServer sets up a simple server with the generated handler.
func StartServer() {
    http.HandleFunc("%s", %s)
    log.Printf("Starting server on :8080 for endpoint %s")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
`, cfg.Path, handlerName, cfg.Path))

		// ...existing code...
		return sb.String()
	}

	return sb.String()
}

// exampleValueForType returns an example value for a given type

func exampleValueForType(fieldType string) string {
	switch fieldType {
	case "string":
		return `"example"`
	case "int":
		return "42"
	case "bool":
		return "true"
	default:
		return "nil"
	}
}
